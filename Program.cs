using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Text.RegularExpressions;

namespace starting
{
    class Help
    {
        private IEnumerable<string> query1;
        private IEnumerable<int> query11;

        public IOrderedEnumerable<string> query { get; set; }
        public Help(IOrderedEnumerable<string> query)
        {
            this.query = query;
            Show();
        }
      
        public Help(IEnumerable<string> query1)
        {
            this.query1 = query1;
            foreach (var item in query1)
            {
                Console.WriteLine(item);
            }
        }
        public Help(IEnumerable<int> query1)
        {
            this.query11 = query1;
            foreach (var item in query1)
            {
                Console.WriteLine(item);
            }
        }

        public void Show()
        {
            foreach (var item in query)
            {
                Console.WriteLine(item);
            }
        }
    }
    class Program
    {


        static void Main(string[] args)
        {
            int[] numb = new int[] { 4, 2, -3, 50, 6, 7, -6, 22, -9, -23, -22, 42, -12 };
            int[] dv = new int[] { 56, 34, 56, 89, 78, 19 };
            var A = new string[] { "hDhjd", "546dsdF4", "Aeros", "Are", "gJhg", "Computers", "4ddf5", "3rz", "3re", "3dfd", "3fer", "sdfsm", "3osme3", "3second3", "2" };
            var R = new string[] { "SDA3", "SYIOOY", "ETR7", "SFDF", "DFHKJF", "DSA3", "ERT6", "DFGD", "ERTER4", "JKLUIO", "FBI" };
            var R2 = new string[] { "SFDFSDF8", "SDF", "DTY9", "TYIOE76DFG", "EH9DFG", "IO234KJ24J2", "CMB", "MIB","DJ" };
            var Q = new string[] { "TYYY.J", "E.RTNB", "SWR.LKU", "UIYUYJKJ", "ILOLHFH", "SDF", "DTY" };
            var posNum1 = new int[] { 5, 98, 7, 12, 48, 63, 47, 32, 54, 69, 32, 14, 25, 85 };
            var posNum2 = new int[] { 45, 78, 69, 3, 24, 38, 63, 65, 71, 25, 36, 12, 32 };
            #region
            /*LinqBegin1. Дана целочисленная последовательность, содержащая как положительные, так и отрицательные числа. Вывести ее первый
            положительный элемент и последний отрицательный элемент.*/

            //var ans= numb.Where(x => x > 0).First();
            //var an = numb.Where(x => x < 0).Last();
            //Console.WriteLine("FirstPositive:"+ans);
            //Console.WriteLine("LastNegative:"+an);



            /*LinqBegin2. Даны цифра D (однозначное целое число) и цело-
            численная последовательность A. Вывести первый положительный
            элемент последовательности A, оканчивающийся цифрой D. Если
            требуемых элементов в последовательности A нет, то вывести 0.*/
            //var D = int.Parse(Console.ReadLine());
            //var ans = dv.Where(x => x % 10 == D).FirstOrDefault();
            //Console.WriteLine("YourNumber:"+D+" Ans:"+ans);

            /*LinqBegin3. Даны целое число L (> 0) и строковая последовательность A. Вывести последнюю строку из A, начинающуюся с цифры
           и имеющую длину L. Если требуемых строк в последовательности A нет, то вывести строку «Not found»*/
            /*Console.WriteLine("Enter Length:");
            var L = int.Parse(Console.ReadLine());
            Console.WriteLine("Enter num which starts with:");
            var num = Console.ReadLine();
           
            var query = from s in A
                        where s.StartsWith(num) && s.Length==L
                        select s;

            Console.WriteLine(query.Last());
            */

            /*LinqBegin4.Дан символ С и строковая последовательность A.Если A содержит единственный элемент, оканчивающийся символом C,
            то вывести этот элемент;если требуемых строк в A нет, то вывести пустую строку; если требуемых строк больше одной, то вывести строку «Error».*/
            /*
            Console.WriteLine("Enter C");
            var C = Console.ReadLine();
            var ans = A.Where(x => x.EndsWith(C)).ToArray();
            foreach (var e in ans)
            {
                if (ans.Length == 1)
                {
                    Console.WriteLine(e);
                }
                else if (ans.Length > 1)
                {
                    Console.WriteLine("Error");
                }
                else if (ans.Length==0)
                {
                    Console.WriteLine(ans.Length);
                    Console.WriteLine("EmptyString");
                }

            }*/
            //try
            //{

            //}
            //catch(Exception)
            //{
            //    throw new Exception("Not found");
            //}



            /*LinqBegin5. Дан символ С и строковая последовательность A. 
             * Найти количество элементов A, которые содержат более од-ного символа и при этом начинаются и оканчиваются симво-лом C.*/
            //var C = Console.ReadLine();

            //var ans = A.Where(x => x.StartsWith(C)&&x.EndsWith(C)&&x.Length!=1).Count();
            //Console.WriteLine("ans:"+ans);



            /*LinqBegin6. Дана строковая последовательность. Найти сумму длин всех строк, входящих в данную последовательность.*/
            //var summa = A.Sum(x=>x.Length);
            //Console.WriteLine("Sum is:"+summa);
            #endregion

            #region
            /*LinqBegin7. Дана целочисленная последовательность. 
            *Найти количество ее отрицательных элементов, а также их сумму. 
             * Если отрицательные элементы отсутствуют, то дважды вы-вести 0.*/
            //var kol = numb.Where(x => x < 0);
            //var cou = kol.Count();
            //var summa = kol.Sum();
            //if (cou == 0)
            //{
            //    Console.WriteLine("00");
            //}
            //else
            //{
            //    Console.WriteLine("kol:" + cou + "  summa:" + summa);
            //}


            /*LinqBegin8. Дана целочисленная последовательность. Найти количество ее положительных двузначных элементов, 
             * а так-же их среднее арифметическое (как вещественное число). 
             * Если требуемые элементы отсутствуют, то дважды вывести 0 (первый раз как целое, второй — как вещественное).*/

            //var ans = numb.Where(x => x > 10);
            //var count = ans.Count();
            //var average = ans.Average();
            //if (count == 0)
            //{
            //    Console.WriteLine("00");
            //}
            //else
            //{
            //    Console.WriteLine("Count:{0} Average:{1}", count, average);
            //}
            //try
            //{
            //    var ans = numb.Where(x => x > 10);
            //    var count = ans.Count();
            //    var average = ans.Average();
            //    Console.WriteLine("Count:{0} Average:{1}", count, average);
            //}
            //catch (InvalidOperationException) { Console.WriteLine("00"); }


            /*LinqBegin9. Дана целочисленная последовательность. 
             * Вывести ее минимальный положительный элемент или число 0, если последовательность не содержит положительных элементов.*/
            //var ans = numb.Where(x => x > 0).Min();
            //if (numb.Where(x => x > 0).Count()==0)
            //{
            //    Console.WriteLine("0");
            //}
            //else
            //{
            //    Console.WriteLine("Ans:" + ans);
            //}



            //try
            //{
            //    var ans = numb.Where(x => x > 0).Min();
            //    Console.WriteLine("Ans:" + ans);
            //}
            //catch (InvalidOperationException)
            //{
            //    Console.WriteLine("0");
            //}

            /*LinqBegin10. Дано целое число L (> 0) и строковая последова-тельность A. 
             * Строки последовательности A содержат только заглавные буквы латинского алфавита.
             * Среди всех строк из A, имеющих длину L, найти наибольшую (в смысле лексико-графического порядка).
             * Вывести эту строку или пустую строку, если последовательность не содержит строк длины L.*/

            /*int L = int.Parse(Console.ReadLine());
            String[] B = { "QWE", "ASD", "ZXC", "ASDA", "OLKJ", "ZXF" };

            var query = from s in B
                        where s.Length == L
                        select s;

            Console.WriteLine(query.Max());*/

            /*LinqBegin11. Дана последовательность непустых строк.
             * Ис-пользуя метод Aggregate, получить строку, состоящую из на-чальных символов всех строк исходной последовательности.*/

            /*var answer = A.Select(x => x.Substring(0, 1)).Aggregate("", (a, e) => a + e);
            Console.WriteLine(answer);*/

            /*LinqBegin12. Дана целочисленная последовательность. Используя метод Aggregate, найти произведение последних цифр всех эле-
        ментов последовательности. Чтобы избежать целочисленного переполнения, при вычислении произведения использовать вещественный числовой тип.*/
            //var ans = from s in dv
            //          select s % 10;
            //var result = 1;
            //foreach (var item in ans) { result *= item; }
            //Console.WriteLine("result: "+result);

            //var asn = dv.Select(x => x % 10).Aggregate(1, (a, e) => a * e);
            //Console.WriteLine("asn: "+asn);

            /*LinqBegin13.Дано целое число N (> 0). 
             * Используя методы Range и Sum, найти сумму 1 + (1/2) + … + (1/N)
             * (как вещественное число).*/
            /* var n = int.Parse(Console.ReadLine());
             var query = Enumerable.Range(1, n).Sum(x=>1.0/x);
             Console.WriteLine(query);*/

            /*LinqBegin14. Даны целые числа A и B (A < B). Используя мето-
ды Range и Average, найти среднее арифметическое квадратов всех
целых чисел от A до B включительно: (A2 + (A + 1)2 + … + B2)/
(B – A + 1) (как вещественное число).*/
            /*var a = int.Parse(Console.ReadLine());//initial
            var b = int.Parse(Console.ReadLine());//final

            var query = Enumerable.Range(a, b - a + 1).Average(x=>Math.Pow(x,2));
            Console.WriteLine(query);*/
            #endregion

            #region
            /*LinqBegin15. Дано целое число N (0  N  15). 
             * Используя методы Range и Aggregate, найти факториал числа N: N! = 1·2·…·N при N  1; 0! = 1. 
             * Чтобы избежать целочисленного переполнения, при вычислении факториала использовать вещественный числовой тип.*/
            /*var n = int.Parse(Console.ReadLine());
            var query = Enumerable.Range(1, n).Aggregate(1.0, (a, e) => a * e);
            Console.WriteLine(query);*/

            /*LinqBegin16. Дана целочисленная последовательность. 
             * Извлечь из нее все положительные числа, сохранив их исходный порядок следования.*/
            /* var ans = numb.Where(x=>x>0).TakeWhile(x=>x>0);
             foreach (var item in ans)
             {
                 Console.WriteLine(item);
             }*/
            /*LinqBegin17. Дана целочисленная последовательность.
             * Извлечь из нее все нечетные числа, сохранив их исходный порядок следования 
             * и удалив все вхождения повторяющихся элементов, кроме первых.*/
            /*var query = numb.Where(x => x % 2 != 0).TakeWhile(x => x % 2 != 0).Distinct();
            foreach (var item in query) { Console.WriteLine(item); }*/

            /*LinqBegin18. Дана целочисленная последовательность.
             * Извлечь из нее все четные отрицательные числа,
             * поменяв порядок извлеченных чисел на обратный.*/
            /*var query = numb.Where(x => x % 2 == 0 &&  x < 0).TakeWhile(x => x < 0).Reverse();
            foreach (var item in query)
            {
                Console.WriteLine(item);
            }*/


            /*LinqBegin19. Даны цифра D (целое однозначное число) и целочисленная последовательность A. 
             * Извлечь из A все различные положительные числа, оканчивающиеся цифрой D (в исходном порядке).
             *При наличии повторяющихся элементов удалять все их вхождения,кроме последних.*/
            /* var D = int.Parse(Console.ReadLine());
             var query = numb.Where(x => x % 10 == D && x > 0).Reverse().Distinct().Reverse();
             foreach (var item in query)
             {
                 Console.WriteLine(item);
             }*/
            /*LinqBegin20. Дана целочисленная последовательность.
             * Извлечь из нее все положительные двузначные числа, 
             * отсортировав их по возрастанию.*/
            /*var query = numb.Where(x => x > 10);
            var ans = from i in query
                      orderby i
                      select i;

            foreach (var item in ans)
            {
                Console.WriteLine(item);
            }*/

            /*LinqBegin21. Дана строковая последовательность. 
             * Строки последовательности содержат только заглавные буквы латинского алфавита.
             * Отсортировать последовательность по возрастанию длин строк, а строки одинаковой длины 
             * – в лексикографическом порядкепо убыванию.*/
            //  IOrderedEnumerable<string> query = R.OrderByDescending(x=>x.Length);
            //foreach (var item in query)
            //{
            //    Console.WriteLine(item);
            //}

            /*LinqBegin22. Даны целое число K (> 0) и строковая последовательность A.
             * Строки последовательности содержат только цифрыи заглавные буквы латинского алфавита.
             * Извлечь из A все строки длины K, оканчивающиеся цифрой, отсортировав их в лексикографическом порядке по возрастанию.*/
            //нужно обобщить чтобы распознавал все числа
            /* var K = int.Parse(Console.ReadLine());
             var query = R.Where(x => x.Length == K && x.EndsWith(@"[0-9]")).OrderBy(x => x);*/

            /*LinqBegin24. Даны целое число K (> 0) и строковая последовательность A.
             * Из элементов A, предшествующих элементу с порядковым номером K, 
             * извлечь те строки, которые имеют нечетную длину и начинаются с заглавной латинской буквы,
             * изменив порядок следования извлеченных строк на обратный.*/
            /*var K = int.Parse(Console.ReadLine());
            IEnumerable<string> query = A.TakeWhile(x => A.Length != K).Where(x => x.Length % 2 != 0 && x.StartsWith("A")).Reverse();*/
            #endregion
            #region
            /*LinqBegin25. Даны целые числа K1 и K2 и целочисленная последовательность A;
             * 1 =<K1 < K2 =< N, где N – размер последовательности A. 
             * Найти сумму положительных элементов последовательности с порядковыми номерами от K1 до K2 включительно.*/
            /* var K1 = int.Parse(Console.ReadLine());
             var K2 = int.Parse(Console.ReadLine());
             var query = numb.Skip(K1).Take(K2).Where(x => x > 0).Sum();*/

            /*LinqBegin26. Даны целые числа K1 и K2 и последовательность непустых строк A;
             * 1 < K1 < K2 <= N, где N – размер последовательности A. 
             * Найти среднее арифметическое длин всех элементов последовательности, 
             * кроме элементов с порядковыми номерами от K1 до K2 включительно, и вывести его как вещественное число.*/
            //var K1 = int.Parse(Console.ReadLine());
            //var K2 = int.Parse(Console.ReadLine());

            //var query = A.Where((n, index) => index < K1 || index > K2).Select(n => n.Length).Average();




            /*LinqBegin27. Даны целое число D и целочисленная последовательность A.
             * Начиная с первого элемента A, большего D, 
             * извлечь из A все нечетные положительные числа,
             * поменяв порядок извлеченных чисел на обратный.*/
            /* var D = int.Parse(Console.ReadLine());
             var query = numb.Where(x => x % 2 != 0 && x>0).Select(x=>x>D).Reverse();
             var ans = from s in numb
                       where s % 2 != 0 && s > 0
                       select s > D;*/ //выводит булеан

            /*LinqBegin28. Даны целое число L (> 0) и последовательность непустых строк A.
             * Строки последовательности содержат только цифры и заглавные буквы латинского алфавита. 
             * Из элементов A, предшествующих первому элементу, длина которого превышает L,
             * извлечь строки, оканчивающиеся буквой.
             * Полученную последовательность отсортировать по убыванию длин строк,
             * а строки одинаковой длины – в лексикографическом порядке по возрастанию.*/
            /* var L = int.Parse(Console.ReadLine());
             String reg = @"^\w*[A-Z]$";

             var ans = R.TakeWhile(x => x.Length < L).Where(x => true == Regex.IsMatch(x, reg, RegexOptions.IgnoreCase)).OrderBy(x => x.Length);*/

            /*LinqBegin29. Даны целые числа D и K (K > 0) и целочисленная последовательность A.
             * Найти теоретико-множественное объединение двух фрагментов A:
             * первый содержит все элементы до первого элемента, большего D (не включая его), 
             * а второй – все элементы, начиная с элемента с порядковым номером K. 
             * Полученную последовательность (не содержащую одинаковых элементов) отсортировать по убыванию.*/
            /*  var D = int.Parse(Console.ReadLine());
              var K = int.Parse(Console.ReadLine());
              var first = numb.TakeWhile((n,index) => index < D);
              var sec = numb.SkipWhile((n, index) => K >= index);

              var ans = first.Union(sec).Distinct().OrderByDescending(x => x);*/

            /*LinqBegin30. Даны целое число K (> 0) и целочисленная последовательность A.
             * Найти теоретико-множественную разность двух фрагментов A:
             * первый содержит все четные числа, а второй – все числа с порядковыми номерами, большими K.
             * В полученной последовательности (не содержащей одинаковых элементов) поменять порядок элементов на обратный*/
            /* var K = int.Parse(Console.ReadLine());
             var first = numb.Where(x => x % 2 == 0);
             var sec = numb.SkipWhile((n, index) => K > index);
             var ans = first.Except(sec).Distinct().Reverse();*/

            /*LinqBegin31. Даны целое число K (> 0) и последовательность непустых строк A. 
             * Строки последовательности содержат только цифры и заглавные буквы латинского алфавита.
             * Найти теоретико-множественное пересечение двух фрагментов A: 
             * первый содержит K начальных элементов, а второй – все элементы, расположенные после последнего элемента,оканчивающегося цифрой.
             * Полученную последовательность (не содержащую одинаковых элементов) отсортировать по возрастанию длин строк, 
             * а строки одинаковой длины в лексикографическом порядке по возрастанию.*/
            /* var K = int.Parse(Console.ReadLine());
             var first = R.TakeWhile((n, index) => K > index);
             var sec = from s in R
                       select s.EndsWith(@"^\w*[0-9]$")
                       .Skip(s.IndexOf(s.Last()));
                       //непонятно
             */
            /*LinqBegin32. Дана последовательность непустых строк A.
             * Получить последовательность символов, каждый элемент которой является начальным символом соответствующей строки из A.
             * Порядок символов должен быть обратным по отношению к порядку элементов исходной последовательности.*/
            /*var query = A.Select(x => x.Substring(0, 1)).Reverse().Aggregate("", (a, e) => a + e);*/
            /*LinqBegin33. Дана целочисленная последовательность.
             * Обрабатывая только положительные числа, получить последовательностьих последних цифр
             * и удалить в полученной последовательности все вхождения одинаковых цифр, кроме первого.
             * Порядок полученных цифр должен соответствовать порядку исходных чисел.*/
            // var query = numb.Where(x => x > 0).Select(x => x % 10).Distinct();

            /*LinqBegin33. Дана целочисленная последовательность.
             * Обрабатывая только положительные числа, получить последовательность их последних цифр
             * и удалить в полученной последовательности все вхождения одинаковых цифр, кроме первого. 
             * Порядок полученных цифр должен соответствовать порядку исходных чисел.*/
            //var query = numb.Where(x => x > 0).Select(x => x % 10).Distinct();

            /*LinqBegin34. Дана последовательность положительных целых чисел.
             * Обрабатывая только нечетные числа, получить последовательность их строковых представлений 
             * и отсортировать ее в лексикографическом порядке по возрастанию.*/
            //var query = numb.Where(x => x > 0).Select(x => x % 2 == 1).ToString().OrderBy(x => x);

            /*LinqBegin35. Дана целочисленная последовательность.
             * Получить последовательность чисел, каждый элемент которой равен произведению соответствующего элемента
             * исходной последовательности на его порядковый номер (1, 2, …).
             * В полученной последовательности удалить все элементы, не являющиеся двузначными,
             * и поменять порядок оставшихся элементов на обратный.*/
            // var ans = numb.Select((n, index) => n * (index+1)).Where(x => x < 10 && x > -10).Reverse();

            /*LinqBegin36. Дана последовательность непустых строк. 
             * Получить последовательность символов, которая определяется следующим образом:
             * если соответствующая строка исходной последовательности имеет нечетную длину, 
             * то в качестве символа берется первый символ этой строки;
             * в противном случае берется последний символ строки.Отсортировать полученные символы по убыванию их кодов.*/

            // var query = A.SelectMany((e, n) => e.Length % 2 == 1 ? e.Substring(0, 1) : e.Substring(e.Length - 1, 1)).OrderBy(x=>x);
            #endregion

            #region
            /*LinqBegin37. Дана строковая последовательность A.
             * Строки последовательности содержат только заглавные буквы латинского алфавита.
             * Получить новую последовательность строк, элементы которой определяются по соответствующим элементам A следующим образом:
             * пустые строки в новую последовательность не включаются, 
             * а к непустым приписывается порядковый номер данной строки в исходной последовательности
             * (например, если пятый элемент A имеет вид «ABC», то в полученной последовательности он будет иметь вид «ABC5»).
             * При нумерации должны учитываться и пустые строки последовательности A. 
             * Отсортировать полученную последовательность в лексикографическом порядке по возрастанию*/
            //var query = R.Select((x, index) => x + (index + 1)).Where(x => x.Length != 1).OrderBy(x=>x);

            /*LinqBegin38. Дана целочисленная последовательность A.
             * Получить новую последовательность чисел, элементы которой определяются по соответствующим 
             * элементам последовательности A следующим образом:
             * если порядковый номер элемента A делится на 3 (3, 6, …), 
             * то этот элемент в новую последовательность не включается; 
             * если остаток от деления порядкового номера на 3 равен 1 (1, 4, …), 
             * то в новую последовательность добавляется удвоенное значение этого элемента;
             * в противном случае (для элементов A с номерами 2, 5, …) элемент добавляется в новую последовательность 
             * без изменений. В полученной последовательности сохранить исходный порядок следования элементов.*/
            //var query = numb.Select((x, index) => (index+1) % 3 == 1 ? x * 2 : x);

            /*LinqBegin39.Дана строковая последовательность A. 
             * Получить последовательность цифровых символов, 
             * входящих в строки последовательности A (символы могут повторяться). 
             * Порядок символов должен соответствовать порядку строк A и порядку следования символов в каждой строке*/
            //var ans = A.SelectMany((e, n) => e.Where(char.IsDigit));



            /*LinqBegin40. Даны число K (> 0) и строковая последовательность A.
             * Получить последовательность символов, содержащую символы всех строк из A,
             * имеющих длину, большую или равную K (символы могут повторяться).
             * В полученной последовательности поменять порядок элементов на обратный.*/
            /* var K = int.Parse(Console.ReadLine());
            var query = A.SelectMany(n => A.Where(x => x.Length >= number).Reverse());
             
            /*LinqBegin41. Даны целое число K (> 0) и строковая последовательность A.
             * Каждый элемент последовательности представляет собой несколько слов из заглавных латинских букв,
             * разделенных символами «.» (точка). Получить последовательность строк, содержащую все слова длины K
             * из элементов A в лексикографическом порядке по возрастанию (слова могут повторяться).*/
            //var K = int.Parse(Console.ReadLine());
            //var ans = Q.SelectMany(p=>p.Split('.')).Where(y=>y.Length == K).OrderBy(x => x);


            /*LinqBegin42. Дана последовательность непустых строк. 
             * Получить последовательность символов, которая определяется следующим образом:
             * для строк с нечетными порядковыми номерами (1, 3, …) в последовательность символов включаются все прописные латинские буквы,
             * содержащиеся в этих строках, а для строк с четными номерами (2, 4, …) – все их строчные латинские буквы.
             * В полученной последовательности символов сохранить их исходный порядок следования.*/
            //var ans = A.SelectMany((e, n) => (n + 1) % 2 == 0 ? e.Where(char.IsLower) : e.Where(char.IsUpper));

            /*LinqBegin43. Даны целое число K (> 0) и последовательность непустых строк A.
             * Получить последовательность символов, которая определяется следующим образом:
             * для первых K элементов последовательности A в новую последовательность заносятся символы,
             * стоящие на нечетных позициях данной строки (1, 3, …),
             * а для остальных элементов A – символы на четных позициях (2, 4, …). 
             * В полученной последовательности поменять порядок элементов на обратный.*/
            //var K = int.Parse(Console.ReadLine());
            //var ans = A.SelectMany((p, i) => i <= K ? p.Where((e, ind) => (ind + 1) % 2 == 1) : p.Where((e, ind) => (ind + 1) % 2 == 0)).Reverse();

            /*LinqBegin44. Даны целые числа K1 и K2 и целочисленные последовательности A и B. 
             * Получить последовательность, содержащую все числа из A, большие K1, 
             * и все числа из B, меньшие K2. Отсортировать полученную последовательность по возрастанию.*/
            /* var K1 = int.Parse(Console.ReadLine());
             var K2 = int.Parse(Console.ReadLine());
             var ans = numb.Where(x => x > K1).Concat(dv.Where(y => y < K2)).OrderBy(x => x);*/

            /*LinqBegin45. Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
             * Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита.
             * Получить последовательность, содержащую все строки из A длины L1 
             * и все строки из B длины L2. Отсортировать полученную последовательность в лексикографическом порядке по убыванию.*/
            /*var L1 = int.Parse(Console.ReadLine());
            var L2 = int.Parse(Console.ReadLine());
            var ans = R.Where(x => x.Length == L1).Concat(R2.Where(x => x.Length == L2)).OrderByDescending(x => x);*/

            /*LinqBegin46. Даны последовательности положительных целых чисел A и B; 
             * все числа в каждой последовательности различны.
             * Найти последовательность всех пар чисел, удовлетворяющих следующим условиям:
             * первый элемент пары принадлежит последовательности A, 
             * второй принадлежит B, и оба элемента оканчиваются одной и той же цифрой.
             * Результирующая последовательность называется внутренним объединением последовательностей A и B 
             * по ключу, определяемому последними цифрами исходных чисел.
             * Представить найденное объединение в виде последовательности строк,
             * содержащих первый и второй элементы пары, разделенные дефисом,
             * например «49-129». Порядок следования пар должен определяться
             * исходным порядком элементов последовательности A, 
             * а для равных первых элементов – порядком элементов последовательности B.*/
            /*
            var ans = posNum1.Join(posNum2,
                p => p % 10,
                p2 => p2 % 10,
                (e, n) => new string[] { $"{e} - {n}" }).SelectMany(w => w);*/

            /*LinqBegin47. Даны последовательности положительных целых чисел A и B;
             * все числа в каждой последовательности различны.
             * Найти внутреннее объединение A и B (см. LinqBegin46), пары в котором должны удовлетворять следующему условию: 
             * последняя цифра первого элемента пары (из A) должна совпадать с первой цифрой 
             * второго элемента пары (из B). Представить найденное объединение в виде последовательности строк,
             * содержащих первый и второй элементы пары, разделенные двоеточием, например «49:921». 
             * Порядок следования пар должен определяться исходным порядком элементов последовательности A,
             * а для равных первых элементов пар –лексикографическим порядком строковых представлений вторых элементов (по возрастанию).*/
            /*var ans = posNum1.Join(posNum2,
                p => p % 10,
                p2 => Char.GetNumericValue(p2.ToString()[0]), (e, n) => new { e, n })
                .GroupBy(x => x.e)
                .SelectMany(x => x.OrderBy(z => z.n))
                .Select(x => $"{x.e}:{x.n}");*/

            /*LinqBegin48. Даны строковые последовательности A и B;
             * все строки в каждой последовательности различны,
             * имеют ненулевую длину и содержат только цифры и заглавные буквы латинского алфавита. 
             * Найти внутреннее объединение A и B (см. LinqBegin46), каждая пара которого должна содержать строки одинаковой длины.
             * Представить найденное объединение в виде последовательности строк,
             * содержащих первый и второй элементы пары, разделенные двоеточием, например «AB:CD».
             * Порядок следования пар должен определяться лексикографическим порядком первых элементов пар (по возрастанию),
             * а для равных первых элементов – лексикографическим порядком вторых элементов пар (по убыванию).*/
            /*var ans = R.Join(R2, p => p.Length, p2 => p2.Length, (e, n) => new { e, n })
                .OrderBy(x => x.e).ThenByDescending(x => x.n)
               .Select(x => $"{x.e}:{x.n}");*/

            /*LinqBegin49. Даны строковые последовательности A, B и С;
             * все строки в каждой последовательности различны, имеют ненулевую длину 
             * и содержат только цифры и заглавные буквы латинского алфавита.
             * Найти внутреннее объединение A, B и С (см. LinqBegin46),каждая тройка которого должна содержать строки,
             * начинающиеся с одного и того же символа.
             * Представить найденное объединение в виде последовательности строк вида «EA=EB=EC», где EA, EB, EC –элементы из A, B, C
             * соответственно. Для различных элементов EA сохраняется исходный порядок их следования,
             * для равных элементов EA порядок троек определяется лексикографическим порядком элементов EB (по возрастанию), 
             * а для равных элементов EA и EB – лексикографическим порядком элементов EC (по убыванию).*/
            /*var ans = R.Join(R2, p => p.First(), e => e.First(), (k, l) => new { k, l }).OrderBy(x => x.k)
                .Join(Q, p => p.k.First(), e => e.First(), (p2, l2) => new { p2.k, p2.l, l2 }).OrderByDescending(x=>x.l)
                .SelectMany(r => new string[] { $"{r.k}={r.l}={r.l2}" });*/

            /*LinqBegin50. Даны строковые последовательности A и B;
             * все строки в каждой последовательности различны и имеют ненулевую длину.
             * Получить последовательность строк вида «E:N», где E обозначает один из элементов последовательности A,
             * а N – количество элементов из B, начинающихся с того же символа, что и элемент E (например, «abc:4»);
             * количество N может быть равно 0. Порядок элементов полученной последовательности должен определяться
             * исходным порядком элементов последовательности A.*/
            /*var ans = R.GroupJoin(Q, p => p[0], p2 => p2[0], 
                (e, n) => new { e, count = n.Count()}).OrderBy(c=>c.e).Select(z => $"{z.e}:{z.count}");*/
            #endregion
            /*LinqBegin51. Даны последовательности положительных целых чисел A и B;
             * все числа в последовательности A различны. 
             * Получить последовательность строк вида «S:E»,
             * где S обозначает сумму тех чисел из B, которые оканчиваются на ту же цифру,
             * что и число E – один из элементов последовательности A (например, «74:23»); 
             * если для числа E не найдено ни одного подходящего числа из последовательности B, 
             * то в качестве S указать 0. Расположить элементы полученной последовательности по возрастанию 
             * значений найденных сумм, а при равных суммах – по убыванию значений элементов A.*/
            /*var ans = posNum1.GroupJoin(posNum2, p => p % 10, p2 => p2 % 10, 
                (e, n) => new { e, sum = n.Sum() }).OrderBy(x => x.sum).Select(z => $"{z.sum}:{z.e}");*/

            /*LinqBegin52. Даны строковые последовательности A и B; 
             * все строки в каждой последовательности различны, имеют ненулевую длину
             * и содержат только цифры и заглавные буквы латинского алфавита.
             * Получить последовательность всевозможных комбинаций вида «EA=EB»,
             * где EA – некоторый элемент из A, EB – некоторый элемент из B, причем оба элемента оканчиваются цифрой (например, «AF3=D78»).
             * Упорядочить полученную последовательность в лексикографическом порядке по возрастанию элементов EA, 
             * а при одинаковых элементах EA – в лексикографическом порядке по убыванию элементов EB*/
            /* var ans = R.Where(x=>char.IsDigit(x.Last())).Join(R2, p =>true, p2 => char.IsDigit(p2.Last()),
                 (e, n) => new { e, n }).OrderBy(z => z.e).ThenByDescending(c => c.n).Select(y=> $"{y.e}={y.n}" );*/

            /*LinqBegin53. Даны целочисленные последовательности A и B.
             * Получить последовательность всех различных сумм, 
             * в которых первое слагаемое берется из A, а второе – из B.
             * Упорядочить полученную последовательность по возрастанию.*/
            //var ans = posNum1.GroupJoin(posNum2, p => 0, p2 => 0,(e,n)=>new { e,n})
            //  .SelectMany(r=>r.n.Select(z => z+r.e)).OrderBy(c=>c);

            /*LinqBegin54. Даны строковые последовательности A и B;
             * все строки в каждой последовательности различны, 
             * имеют ненулевую длину и содержат только цифры и заглавные буквы латинского алфавита.
             * Найти последовательность всех пар строк, удовлетворяющих следующим условиям:
             * первый элемент пары принадлежит последовательности A,
             * а второй либо является одним из элементов последовательности B, начинающихся с того же символа,
             * что и первый элемент пары, либо является пустой строкой (если B не содержит ни одной подходящей строки). 
             * Результирующая последовательность называется левым внешним объединением последовательностей A и B по ключу,
             * определяемому первыми символами исходных строк. Представить найденное объединение в виде последовательности 
             * строк вида «EA.EB», где EA – элемент из A, а EB – либо один из соответствующих ему элементов из B, либо пустая строка. 
             * Расположить элементы полученной строковой последовательности в лексикографическом порядке по возрастанию.*/
            // var ans = R.GroupJoin(R2, p => p.First(), p2 => p2.First(), (e, n) => n.DefaultIfEmpty("").Select(z => $"{e}.{z}"))
            //     .SelectMany(s => s).OrderBy(o => o);

            /*LinqBegin55. Даны последовательности положительных целых чисел A и B;
             * все числа в каждой последовательности различны.
             * Найти левое внешнее объединение A и B (см. LinqBegin54),
             * пары в котором должны удовлетворять следующему условию:
             * оба элемента пары оканчиваются одной и той же цифрой.
             * Представить найденное объединение в виде последовательности строк вида «EA:EB»,
             * где EA – число из A, а EB – либо одно из соответствующих ему чисел из B, либо 0
             * (если в B не содержится чисел, соответствующих EA).
             * Расположить элементы полученной последовательности по убыванию чисел EA,
             * а при одинаковых числах EA – по возрастанию чисел EB.*/
            /*var ans = posNum1.GroupJoin(posNum2, p => p % 10, p2 => p2 % 10, 
                (e, n) => n.DefaultIfEmpty(0).Select(z => $"{e}:{z}")).SelectMany(s=>s).OrderByDescending(o => o);//endsWith

            var ans2 = posNum1.GroupJoin(posNum2, p => Char.GetNumericValue(p.ToString()[0]), p2 => Char.GetNumericValue(p2.ToString()[0]),
                (e, n) => n.DefaultIfEmpty(0).Select(z => $"{e}:{z}")).SelectMany(s => s).OrderByDescending(o => o);//startsWith
                */

            /*LinqBegin56. Дана целочисленная последовательность A. 
             * Сгруппировать элементы последовательности A, оканчивающиеся одной и той же цифрой,
             * и на основе этой группировки получить последовательность строк вида «D:S»,
             * где D – ключ группировки (то есть некоторая цифра, которой оканчивается хотя бы одно из чисел последовательности A),
             * а S – сумма всех чисел из A, которые оканчиваются цифрой D. 
             * Полученную последовательность упорядочить по возрастанию ключей.*/
            /*var ans = numb.GroupBy(p => Char.GetNumericValue(p.ToString().Last()), 
                (K, s) => new { K, S = s.Sum() }).OrderBy(o => o.K).Select(z=>$"{z.K}:{z.S}");*/

            /*LinqBegin57. Дана целочисленная последовательность.
             * Среди всех элементов последовательности, оканчивающихся одной и той же цифрой, выбрать максимальный.
             * Полученную последовательность максимальных элементов упорядочить по возрастанию их последних цифр.*/
            /*var ans=posNum1.GroupBy(p=> Char.GetNumericValue(p.ToString().Last()), 
                (K, m) => new { K, M = m.Max() }).OrderBy(o => o.K).Select(z => $"{z.K}:{z.M}");*/

            /*LinqBegin58. Дана последовательность непустых строк.
             * Среди всех строк, начинающихся с одного и того же символа, 
             * выбрать наиболее длинную. Если таких строк несколько, 
             * то выбрать первую по порядку их следования в исходной последовательности.
             * Полученную последовательность строк упорядочить по возрастанию кодов их начальных символов.*/
            //var ans = R.GroupBy(p => p.First(), (K, m) => new { K, M = m.Max() }).OrderBy(o => o.K).Select(ss => $"{ss.K}.{ss.M}");

            /*LinqBegin59. Дана последовательность непустых строк, содержащих только заглавные буквы латинского алфавита. 
             * Среди всех строк одинаковой длины выбрать первую в лексикографическом порядке (по возрастанию). 
             * Полученную последовательность строк упорядочить по убыванию их длин*/
            //var ans = R.GroupBy(p => p.Length,  (K, m) => new { K, M = m.OrderBy(o => o).First() })
            //    .OrderByDescending(oo => oo.K).Select(z=>$"{z.K}:{z.M}");

            /*LinqBegin60. Дана последовательность непустых строк A,
             * содержащих только заглавные буквы латинского алфавита.
             * Для всех строк, начинающихся с одной и той же буквы,
             * определить их суммарную длину и получить последовательность строк вида «S-C»,
             * где S – суммарная длина всех строк из A, которые начинаются с буквы С.
             * Полученную последовательность упорядочить по убыванию числовых значений сумм,
             * а при равных значениях сумм – по возрастанию кодов символов C.*/
            /* var ans = R.GroupBy(p => p.First(), e => e.Length, (K, s) => new { K, S = s.Sum() })
                .OrderByDescending(o => o.S).ThenBy(oo => oo.K).Select(s => $"{s.K}-{s.S}");*/
            ///////////////////the enddddddddddd-----------------------------------------------------------------
            //foreach (var item in ans) { Console.WriteLine(item); }
            //Help help = new Help(query);
            Console.WriteLine(query);
            Console.ReadKey();
            
        }

    }
}


